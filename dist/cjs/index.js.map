{"version":3,"file":"index.js","sources":["../../src/vuexmodule.ts","../../src/module/stateFactory.ts","../../src/helpers.ts","../../src/module/staticGenerators.ts","../../src/module/index.ts","../../src/action.ts","../../src/mutation.ts","../../src/mutationaction.ts"],"sourcesContent":["import {\r\n  ActionTree,\r\n  GetterTree,\r\n  Module as Mod,\r\n  ModuleTree,\r\n  MutationTree,\r\n  Store,\r\n  ActionContext\r\n} from 'vuex'\r\n\r\nexport class VuexModule<S = ThisType<S>, R = any> implements Mod<S, R> {\r\n  /*\r\n   * To use with `extends Class` syntax along with decorators\r\n   */\r\n  static namespaced?: boolean\r\n  static state?: any | (() => any)\r\n  static getters?: GetterTree<any, any>\r\n  static actions?: ActionTree<any, any>\r\n  static mutations?: MutationTree<any>\r\n  static modules?: ModuleTree<any>\r\n\r\n  /*\r\n   * To use with `new VuexModule(<ModuleOptions>{})` syntax\r\n   */\r\n\r\n  modules?: ModuleTree<any>\r\n  namespaced?: boolean\r\n  getters?: GetterTree<S, R>\r\n  state?: S | (() => S)\r\n  mutations?: MutationTree<S>\r\n  actions?: ActionTree<S, R>\r\n  context!: ActionContext<S, R>\r\n\r\n  constructor(module: Mod<S, any>) {\r\n    this.actions = module.actions\r\n    this.mutations = module.mutations\r\n    this.state = module.state\r\n    this.getters = module.getters\r\n    this.namespaced = module.namespaced\r\n    this.modules = module.modules\r\n  }\r\n}\r\ntype ConstructorOf<C> = { new (...args: any[]): C }\r\n\r\nexport function getModule<M extends VuexModule>(\r\n  moduleClass: ConstructorOf<M>,\r\n  store?: Store<any>\r\n): M {\r\n  if ((moduleClass as any)._statics) {\r\n    return (moduleClass as any)._statics\r\n  }\r\n  const genStatic: (providedStore?: Store<any>) => M = (moduleClass as any)._genStatic\r\n  if (!genStatic) {\r\n    throw new Error(`ERR_GET_MODULE_NO_STATICS : Could not get module accessor. \r\n      Make sure your module has name, we can't make accessors for unnamed modules\r\n      i.e. @Module({ name: 'something' })`)\r\n  }\r\n  return ((moduleClass as any)._statics = genStatic(store))\r\n}\r\n","import { Module as Mod } from 'vuex'\r\n\r\nconst reservedKeys = ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\r\nexport function stateFactory<S>(module: Function & Mod<S, any>) {\r\n  const state = new module.prototype.constructor({})\r\n  const s = {} as S\r\n  Object.keys(state).forEach((key: string) => {\r\n    if (reservedKeys.indexOf(key) !== -1) {\r\n      if (typeof state[key] !== 'undefined') {\r\n        throw new Error(\r\n          `ERR_RESERVED_STATE_KEY_USED: You cannot use the following\r\n        ['actions', 'getters', 'mutations', 'modules', 'state', 'namespaced', 'commit']\r\n        as fields in your module. These are reserved as they have special purpose in Vuex`\r\n        )\r\n      }\r\n      return\r\n    }\r\n    if (state.hasOwnProperty(key)) {\r\n      if (typeof state[key] !== 'function') {\r\n        ;(s as any)[key] = state[key]\r\n      }\r\n    }\r\n  })\r\n\r\n  return s\r\n}\r\n","/**\r\n * Takes the properties on object from parameter source and adds them to the object\r\n * parameter target\r\n * @param {object} target  Object to have properties copied onto from y\r\n * @param {object} source  Object with properties to be copied to x\r\n */\r\nexport function addPropertiesToObject(target: any, source: any) {\r\n  for (let k of Object.keys(source || {})) {\r\n    Object.defineProperty(target, k, {\r\n      get: () => source[k]\r\n    })\r\n  }\r\n}\r\n","import { ActionTree, GetterTree, Module as Mod, MutationTree } from 'vuex'\r\nimport { DynamicModuleOptions } from '../moduleoptions'\r\n\r\nexport function staticStateGenerator<S>(\r\n  module: Function & Mod<S, any>,\r\n  modOpt: DynamicModuleOptions,\r\n  statics: any\r\n) {\r\n  Object.keys(module.state as S).forEach((key) => {\r\n    if ((module.state as S).hasOwnProperty(key)) {\r\n      // If not undefined or function means it is a state value\r\n      if (['undefined', 'function'].indexOf(typeof (module.state as any)[key]) === -1) {\r\n        Object.defineProperty(statics, key, {\r\n          get() {\r\n            return modOpt.store.state[modOpt.name][key]\r\n          }\r\n        })\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nexport function staticGetterGenerator<S>(\r\n  module: Function & Mod<S, any>,\r\n  modOpt: DynamicModuleOptions,\r\n  statics: any\r\n) {\r\n  Object.keys(module.getters as GetterTree<S, any>).forEach((key) => {\r\n    if (module.namespaced) {\r\n      Object.defineProperty(statics, key, {\r\n        get() {\r\n          return modOpt.store.getters[`${modOpt.name}/${key}`]\r\n        }\r\n      })\r\n    } else {\r\n      Object.defineProperty(statics, key, {\r\n        get() {\r\n          return modOpt.store.getters[key]\r\n        }\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\nexport function staticMutationGenerator<S>(\r\n  module: Function & Mod<S, any>,\r\n  modOpt: DynamicModuleOptions,\r\n  statics: any\r\n) {\r\n  Object.keys(module.mutations as MutationTree<S>).forEach((key) => {\r\n    if (module.namespaced) {\r\n      statics[key] = function(...args: any[]) {\r\n        modOpt.store.commit(`${modOpt.name}/${key}`, ...args)\r\n      }\r\n    } else {\r\n      statics[key] = function(...args: any[]) {\r\n        modOpt.store.commit(key, ...args)\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nexport function staticActionGenerators<S>(\r\n  module: Function & Mod<S, any>,\r\n  modOpt: DynamicModuleOptions,\r\n  statics: any\r\n) {\r\n  Object.keys(module.actions as ActionTree<S, any>).forEach((key) => {\r\n    if (module.namespaced) {\r\n      statics[key] = async function(...args: any[]) {\r\n        return modOpt.store.dispatch(`${modOpt.name}/${key}`, ...args)\r\n      }\r\n    } else {\r\n      statics[key] = async function(...args: any[]) {\r\n        return modOpt.store.dispatch(key, ...args)\r\n      }\r\n    }\r\n  })\r\n}\r\n","import { GetterTree, Module as Mod, Store } from 'vuex'\r\nimport { DynamicModuleOptions, ModuleOptions } from '../moduleoptions'\r\nimport { stateFactory as sf } from './stateFactory'\r\nimport { addPropertiesToObject } from '../helpers'\r\nimport {\r\n  staticActionGenerators,\r\n  staticGetterGenerator,\r\n  staticMutationGenerator,\r\n  staticStateGenerator\r\n} from './staticGenerators'\r\n\r\nfunction moduleDecoratorFactory<S>(moduleOptions: ModuleOptions) {\r\n  return function<TFunction extends Function>(constructor: TFunction): TFunction | void {\r\n    const module: Function & Mod<S, any> = constructor\r\n    const stateFactory = () => sf(module)\r\n\r\n    if (!module.state) {\r\n      module.state = moduleOptions && moduleOptions.stateFactory ? stateFactory : stateFactory()\r\n    }\r\n    if (!module.getters) {\r\n      module.getters = {} as GetterTree<S, any>\r\n    }\r\n    if (!module.namespaced) {\r\n      module.namespaced = moduleOptions && moduleOptions.namespaced\r\n    }\r\n    Object.getOwnPropertyNames(module.prototype).forEach((funcName: string) => {\r\n      const descriptor = Object.getOwnPropertyDescriptor(\r\n        module.prototype,\r\n        funcName\r\n      ) as PropertyDescriptor\r\n      if (descriptor.get && module.getters) {\r\n        module.getters[funcName] = function(\r\n          state: S,\r\n          getters: GetterTree<S, any>,\r\n          rootState: any,\r\n          rootGetters: GetterTree<any, any>\r\n        ) {\r\n          const thisObj = { context: { state, getters, rootState, rootGetters } }\r\n          addPropertiesToObject(thisObj, state)\r\n          addPropertiesToObject(thisObj, getters)\r\n          const got = (descriptor.get as Function).call(thisObj)\r\n          return got\r\n        }\r\n      }\r\n    })\r\n    const modOpt = moduleOptions as DynamicModuleOptions\r\n    if (modOpt.name) {\r\n      Object.defineProperty(constructor, '_genStatic', {\r\n        value: (store?: Store<any>) => {\r\n          let statics = {}\r\n          modOpt.store = modOpt.store || store\r\n          if (!modOpt.store) {\r\n            throw new Error(`ERR_STORE_NOT_PROVIDED: To use getModule(), either the module\r\n            should be decorated with store in decorator, i.e. @Module({store: store}) or\r\n            store should be passed when calling getModule(), i.e. getModule(MyModule, this.$store)`)\r\n          }\r\n          // ===========  For statics ==============\r\n          // ------ state -------\r\n          staticStateGenerator(module, modOpt, statics)\r\n\r\n          // ------- getters -------\r\n          if (module.getters) {\r\n            staticGetterGenerator(module, modOpt, statics)\r\n          }\r\n\r\n          // -------- mutations --------\r\n          if (module.mutations) {\r\n            staticMutationGenerator(module, modOpt, statics)\r\n          }\r\n          // -------- actions ---------\r\n          if (module.actions) {\r\n            staticActionGenerators(module, modOpt, statics)\r\n          }\r\n          return statics\r\n        }\r\n      })\r\n    }\r\n\r\n    if (modOpt.dynamic) {\r\n      if (!modOpt.name) {\r\n        throw new Error('Name of module not provided in decorator options')\r\n      }\r\n      modOpt.store.registerModule(\r\n        modOpt.name, // TODO: Handle nested modules too in future\r\n        module,\r\n        { preserveState: modOpt.preserveState || false }\r\n      )\r\n    }\r\n    return constructor\r\n  }\r\n}\r\n\r\nexport function Module<S>(module: Function & Mod<S, any>): void\r\nexport function Module<S>(options: ModuleOptions): ClassDecorator\r\n\r\nexport function Module<S>(modOrOpt: ModuleOptions | Function & Mod<S, any>) {\r\n  if (typeof (modOrOpt as any) === 'function') {\r\n    /*\r\n     * @Module decorator called without options (directly on the class definition)\r\n     */\r\n    moduleDecoratorFactory({})(modOrOpt as Function & Mod<S, any>)\r\n  } else {\r\n    /*\r\n     * @Module({...}) decorator called with options\r\n     */\r\n    return moduleDecoratorFactory(modOrOpt)\r\n  }\r\n}\r\n","import { Action as Act, ActionContext, Module as Mod, Payload } from 'vuex'\r\nimport { getModule, VuexModule } from './vuexmodule'\r\nimport { addPropertiesToObject } from './helpers'\r\n\r\n/**\r\n * Parameters that can be passed to the @Action decorator\r\n */\r\nexport interface ActionDecoratorParams {\r\n  commit?: string\r\n  rawError?: boolean\r\n}\r\nfunction actionDecoratorFactory<T>(params?: ActionDecoratorParams): MethodDecorator {\r\n  const { commit = undefined, rawError = false } = params || {}\r\n  return function(target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<any>) {\r\n    const module = target.constructor as Mod<T, any>\r\n    if (!module.actions) {\r\n      module.actions = {}\r\n    }\r\n    const actionFunction: Function = descriptor.value\r\n    const action: Act<typeof target, any> = async function(\r\n      context: ActionContext<typeof target, any>,\r\n      payload: Payload\r\n    ) {\r\n      try {\r\n        let actionPayload = null\r\n\r\n        if ((module as any)._genStatic) {\r\n          const moduleAccessor = getModule(module as typeof VuexModule)\r\n          moduleAccessor.context = context\r\n          actionPayload = await actionFunction.call(moduleAccessor, payload)\r\n        } else {\r\n          const thisObj = { context }\r\n          addPropertiesToObject(thisObj, context.state)\r\n          addPropertiesToObject(thisObj, context.getters)\r\n          actionPayload = await actionFunction.call(thisObj, payload)\r\n        }\r\n        if (commit) {\r\n          context.commit(commit, actionPayload)\r\n        }\r\n        return actionPayload\r\n      } catch (e) {\r\n        throw rawError\r\n          ? e\r\n          : new Error(\r\n              'ERR_ACTION_ACCESS_UNDEFINED: Are you trying to access ' +\r\n                'this.someMutation() or this.someGetter inside an @Action? \\n' +\r\n                'That works only in dynamic modules. \\n' +\r\n                'If not dynamic use this.context.commit(\"mutationName\", payload) ' +\r\n                'and this.context.getters[\"getterName\"]' +\r\n                '\\n' +\r\n                new Error(`Could not perform action ${key.toString()}`).stack +\r\n                '\\n' +\r\n                e.stack\r\n            )\r\n      }\r\n    }\r\n    module.actions[key as string] = action\r\n  }\r\n}\r\n\r\nexport function Action<T, R>(\r\n  target: T,\r\n  key: string | symbol,\r\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\r\n): void\r\nexport function Action<T>(params: ActionDecoratorParams): MethodDecorator\r\n\r\n/**\r\n * The @Action decorator turns an async function into an Vuex action\r\n *\r\n * @param targetOrParams the module class\r\n * @param key name of the action\r\n * @param descriptor the action function descriptor\r\n * @constructor\r\n */\r\nexport function Action<T, R>(\r\n  targetOrParams: T | ActionDecoratorParams,\r\n  key?: string | symbol,\r\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => R>\r\n) {\r\n  if (!key && !descriptor) {\r\n    /*\r\n     * This is the case when `targetOrParams` is params.\r\n     * i.e. when used as -\r\n     * <pre>\r\n        @Action({commit: 'incrCount'})\r\n        async getCountDelta() {\r\n          return 5\r\n        }\r\n     * </pre>\r\n     */\r\n    return actionDecoratorFactory(targetOrParams as ActionDecoratorParams)\r\n  } else {\r\n    /*\r\n     * This is the case when @Action is called on action function\r\n     * without any params\r\n     * <pre>\r\n     *   @Action\r\n     *   async doSomething() {\r\n     *    ...\r\n     *   }\r\n     * </pre>\r\n     */\r\n    actionDecoratorFactory()(targetOrParams, key!, descriptor!)\r\n  }\r\n}\r\n","import { Module as Mod, Mutation as Mut, Payload } from 'vuex'\r\n\r\nexport function Mutation<T, R>(\r\n  target: T,\r\n  key: string | symbol,\r\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\r\n) {\r\n  const module = target.constructor as Mod<T, any>\r\n  if (!module.mutations) {\r\n    module.mutations = {}\r\n  }\r\n  const mutationFunction: Function = descriptor.value ? descriptor.value : (...args: any[]) => ({})\r\n  const mutation: Mut<typeof target> = function(state: typeof target, payload: Payload) {\r\n    mutationFunction.call(state, payload)\r\n  }\r\n  module.mutations[key as string] = mutation\r\n}\r\n","import { Action as Act, ActionContext, Module as Mod, Mutation as Mut, Payload, Store } from 'vuex'\r\n\r\nexport interface MutationActionParams<M> {\r\n  mutate?: (keyof Partial<M>)[]\r\n  rawError?: boolean\r\n}\r\n\r\nfunction mutationActionDecoratorFactory<T>(params: MutationActionParams<T>) {\r\n  return function(\r\n    target: T,\r\n    key: string | symbol,\r\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T>>>\r\n  ) {\r\n    const module = target.constructor as Mod<T, any>\r\n    if (!module.mutations) {\r\n      module.mutations = {}\r\n    }\r\n    if (!module.actions) {\r\n      module.actions = {}\r\n    }\r\n    const mutactFunction = descriptor.value as ((payload: any) => Promise<any>)\r\n\r\n    const action: Act<typeof target, any> = async function(\r\n      context: ActionContext<typeof target, any>,\r\n      payload: Payload\r\n    ) {\r\n      try {\r\n        const actionPayload = await mutactFunction.call(context, payload)\r\n        context.commit(key as string, actionPayload)\r\n      } catch (e) {\r\n        if (params.rawError) {\r\n          throw e\r\n        } else {\r\n          console.error('Could not perform action ' + key.toString())\r\n          console.error(e)\r\n        }\r\n      }\r\n    }\r\n\r\n    const mutation: Mut<typeof target> = function(\r\n      state: typeof target | Store<T>,\r\n      payload: Payload & { [k in keyof T]: any }\r\n    ) {\r\n      if (!params.mutate) {\r\n        params.mutate = Object.keys(payload) as (keyof T)[]\r\n      }\r\n      for (let stateItem of params.mutate) {\r\n        if (state.hasOwnProperty(stateItem) && payload.hasOwnProperty(stateItem)) {\r\n          ;(state as T)[stateItem] = payload[stateItem]\r\n        } else {\r\n          throw new Error(`ERR_MUTATE_PARAMS_NOT_IN_PAYLOAD\r\n          In @MutationAction, mutate: ['a', 'b', ...] array keys must\r\n          match with return type = {a: {}, b: {}, ...} and must\r\n          also be in state.`)\r\n        }\r\n      }\r\n    }\r\n    module.actions[key as string] = action\r\n    module.mutations[key as string] = mutation\r\n  }\r\n}\r\n\r\nexport function MutationAction<K, T extends K>(\r\n  target: { [k in keyof T]: T[k] | null },\r\n  key: string | symbol,\r\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<K>>\r\n): void\r\n\r\nexport function MutationAction<T>(\r\n  params: MutationActionParams<T>\r\n): (\r\n  target: T,\r\n  key: string | symbol,\r\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<T>>\r\n) => void\r\n\r\n/**\r\n * The @MutationAction decorator turns this into an action that further calls a mutation\r\n * Both the action and the mutation are generated for you\r\n *\r\n * @param paramsOrTarget the params or the target class\r\n * @param key the name of the function\r\n * @param descriptor the function body\r\n * @constructor\r\n */\r\nexport function MutationAction<T, K, M extends K>(\r\n  paramsOrTarget: MutationActionParams<T> | M,\r\n  key?: string | symbol,\r\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<K>>>\r\n):\r\n  | ((\r\n      target: T,\r\n      key: string | symbol,\r\n      descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T>>>\r\n    ) => void)\r\n  | void {\r\n  if (!key && !descriptor) {\r\n    /*\r\n     * This is the case when `paramsOrTarget` is params.\r\n     * i.e. when used as -\r\n     * <pre>\r\n        @MutationAction({mutate: ['incrCount']})\r\n        async getCountDelta() {\r\n          return {incrCount: 5}\r\n        }\r\n     * </pre>\r\n     */\r\n    return mutationActionDecoratorFactory(paramsOrTarget as MutationActionParams<T>)\r\n  } else {\r\n    /*\r\n     * This is the case when `paramsOrTarget` is target.\r\n     * i.e. when used as -\r\n     * <pre>\r\n        @MutationAction\r\n        async getCountDelta() {\r\n          return {incrCount: 5}\r\n        }\r\n     * </pre>\r\n     */\r\n    mutationActionDecoratorFactory({} as MutationActionParams<K>)(\r\n      paramsOrTarget as K,\r\n      key!,\r\n      descriptor!\r\n    )\r\n  }\r\n}\r\n"],"names":["stateFactory","sf"],"mappings":"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"}